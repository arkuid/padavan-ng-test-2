<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Padavan-ng Releases</title>
    <style>
        /* ... (оставляем все стили без изменений) ... */
    </style>
</head>
<body>
    <!-- ... (оставляем HTML без изменений) ... -->

    <script>
        // Конфигурация
        const REPO_OWNER = 'arkuid';
        const REPO_NAME = 'padavan-ng-test-2';
        const API_URL = `https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/releases`;
        const UPDATE_INTERVAL = 20 * 60 * 1000; // 20 минут в миллисекундах
        const STORAGE_KEY = 'padavan_ng_last_update';
        const DATA_STORAGE_KEY = 'padavan_ng_cached_data';
        
        // Переменные состояния
        let allReleases = [];
        let toolchainReleases = [];
        let firmwareReleases = [];
        let routerModels = new Set();
        let nextUpdateTimer = null;
        
        // DOM элементы
        const searchInput = document.getElementById('search-input');
        const typeFilter = document.getElementById('type-filter');
        const modelFilter = document.getElementById('model-filter');
        const errorMessage = document.getElementById('error-message');
        const infoMessage = document.getElementById('info-message');
        const refreshBtn = document.getElementById('refresh-btn');
        const forceRefreshBtn = document.getElementById('force-refresh-btn');
        const lastUpdate = document.getElementById('last-update');
        const nextUpdateInfo = document.getElementById('next-update-info');
        
        // Инициализация
        document.addEventListener('DOMContentLoaded', () => {
            checkAndLoadReleases();
            setupEventListeners();
        });
        
        // Проверка времени последнего обновления и загрузка данных
        function checkAndLoadReleases() {
            showLoading(true);
            
            const lastUpdateTime = getLastUpdateTime();
            const now = new Date().getTime();
            const timeSinceLastUpdate = now - lastUpdateTime;
            
            if (timeSinceLastUpdate === 0 || timeSinceLastUpdate > UPDATE_INTERVAL) {
                // Нет записи о времени обновления ИЛИ прошло больше 20 минут
                console.log('Загрузка свежих данных:', {
                    lastUpdateTime: new Date(lastUpdateTime).toLocaleString(),
                    timeSinceLastUpdate: formatTime(timeSinceLastUpdate)
                });
                loadReleases(false);
            } else {
                // Еще не прошло 20 минут - загружаем кэшированные данные
                console.log('Загрузка кэшированных данных:', {
                    timeSinceLastUpdate: formatTime(timeSinceLastUpdate),
                    timeUntilNextUpdate: formatTime(UPDATE_INTERVAL - timeSinceLastUpdate)
                });
                loadCachedData();
                
                // Планируем следующее обновление
                const timeUntilNextUpdate = UPDATE_INTERVAL - timeSinceLastUpdate;
                scheduleNextUpdate(timeUntilNextUpdate);
                showInfo(`Следующее обновление через ${formatTime(timeUntilNextUpdate)}`);
            }
        }
        
        // Загрузка кэшированных данных
        function loadCachedData() {
            try {
                const cachedData = localStorage.getItem(DATA_STORAGE_KEY);
                if (cachedData) {
                    const data = JSON.parse(cachedData);
                    
                    // Проверяем структуру данных
                    if (!data || !data.allReleases || !Array.isArray(data.allReleases)) {
                        throw new Error('Некорректный формат кэшированных данных');
                    }
                    
                    allReleases = data.allReleases;
                    toolchainReleases = data.toolchainReleases || [];
                    firmwareReleases = data.firmwareReleases || [];
                    routerModels = new Set(data.routerModels || []);
                    
                    updateUI();
                    
                    // Обновляем время последнего обновления
                    const lastUpdateTime = getLastUpdateTime();
                    if (lastUpdateTime > 0) {
                        lastUpdate.textContent = new Date(lastUpdateTime).toLocaleString('ru-RU');
                    }
                    
                    showLoading(false);
                } else {
                    // Нет кэшированных данных - загружаем новые
                    console.log('Нет кэшированных данных, загружаем с GitHub');
                    loadReleases(false);
                }
            } catch (error) {
                console.error('Ошибка загрузки кэшированных данных:', error);
                console.log('Загружаем свежие данные из-за ошибки кэша');
                loadReleases(false);
            }
        }
        
        // Загрузка данных с GitHub API
        async function loadReleases(force = false) {
            showLoading(true);
            hideError();
            hideInfo();
            
            try {
                console.log('Начинаем загрузку данных с GitHub API...');
                const response = await fetch(API_URL);
                
                if (!response.ok) {
                    throw new Error(`GitHub API вернул ошибку: ${response.status} ${response.statusText}`);
                }
                
                const data = await response.json();
                
                if (!Array.isArray(data)) {
                    throw new Error('Некорректный формат данных от GitHub API');
                }
                
                console.log(`Получено ${data.length} релизов с GitHub`);
                allReleases = data;
                processReleases();
                updateUI();
                
                // Сохраняем время обновления
                const updateTime = new Date().getTime();
                localStorage.setItem(STORAGE_KEY, updateTime.toString());
                
                // Сохраняем данные в кэш
                saveDataToCache();
                
                // Обновляем время последнего обновления
                lastUpdate.textContent = new Date(updateTime).toLocaleString('ru-RU');
                
                // Планируем следующее обновление через 20 минут
                scheduleNextUpdate(UPDATE_INTERVAL);
                
                // Показываем сообщение об успешном обновлении
                showInfo(`Данные успешно обновлены. Следующее обновление через 20 минут.`);
                
                console.log('Данные успешно загружены и сохранены в кэш');
                
            } catch (error) {
                console.error('Ошибка загрузки данных:', error);
                showError(`Не удалось загрузить данные: ${error.message}`);
                
                // Пробуем загрузить кэшированные данные
                if (!force) {
                    console.log('Пробуем загрузить кэшированные данные после ошибки...');
                    loadCachedData();
                }
            } finally {
                showLoading(false);
            }
        }
        
        // Сохранение данных в кэш
        function saveDataToCache() {
            try {
                const dataToCache = {
                    allReleases: allReleases,
                    toolchainReleases: toolchainReleases,
                    firmwareReleases: firmwareReleases,
                    routerModels: Array.from(routerModels),
                    timestamp: new Date().getTime()
                };
                localStorage.setItem(DATA_STORAGE_KEY, JSON.stringify(dataToCache));
                console.log('Данные сохранены в кэш');
            } catch (error) {
                console.error('Ошибка сохранения данных в кэш:', error);
            }
        }
        
        // Получение времени последнего обновления из localStorage
        function getLastUpdateTime() {
            const storedTime = localStorage.getItem(STORAGE_KEY);
            return storedTime ? parseInt(storedTime) : 0;
        }
        
        // Планирование следующего обновления
        function scheduleNextUpdate(delay) {
            // Очищаем предыдущий таймер
            if (nextUpdateTimer) {
                clearTimeout(nextUpdateTimer);
            }
            
            // Устанавливаем новый таймер
            nextUpdateTimer = setTimeout(() => {
                console.log('Таймер сработал, загружаем свежие данные...');
                loadReleases(false);
            }, delay);
            
            // Обновляем информацию о следующем обновлении
            const nextUpdateTime = new Date(Date.now() + delay);
            nextUpdateInfo.textContent = `Следующее обновление: ${nextUpdateTime.toLocaleString('ru-RU')}`;
            
            console.log(`Запланировано обновление через ${formatTime(delay)}`);
        }
        
        // Форматирование времени в читаемый вид
        function formatTime(ms) {
            const minutes = Math.floor(ms / 60000);
            const seconds = Math.floor((ms % 60000) / 1000);
            
            if (minutes > 0) {
                return `${minutes} мин ${seconds} сек`;
            } else {
                return `${seconds} сек`;
            }
        }
        
        // Остальные функции без изменений (processReleases, updateUI, createFileCard и т.д.)
        // ... (копируем все остальные функции из предыдущего кода) ...
        
        // Обработка релизов
        function processReleases() {
            toolchainReleases = [];
            firmwareReleases = [];
            routerModels.clear();
            
            allReleases.forEach(release => {
                const isToolchain = release.tag_name === 'latest' || 
                                    (release.name && release.name.toLowerCase().includes('toolchain'));
                
                if (!release.assets || !Array.isArray(release.assets)) {
                    return;
                }
                
                release.assets.forEach(asset => {
                    // Создаем объект файла с правильными данными из GitHub API
                    const fileItem = {
                        id: `${release.id}-${asset.id}`,
                        name: release.name || 'Без названия',
                        fileName: asset.name,
                        downloadUrl: asset.browser_download_url,
                        // Используем реальный размер из GitHub API
                        size: formatFileSize(asset.size),
                        date: new Date(asset.created_at || release.created_at),
                        description: release.body || '',
                        type: isToolchain ? 'toolchain' : 'firmware'
                    };
                    
                    if (isToolchain) {
                        toolchainReleases.push(fileItem);
                    } else {
                        // Извлекаем модель роутера
                        const model = extractRouterModel(release.name, release.body);
                        if (model) {
                            fileItem.model = model;
                            routerModels.add(model);
                        }
                        firmwareReleases.push(fileItem);
                    }
                });
            });
            
            // Сортируем прошивки по дате (новые сначала)
            firmwareReleases.sort((a, b) => b.date - a.date);
        }
        
        // Извлечение модели роутера из названия релиза или описания
        function extractRouterModel(name, description) {
            if (!name) return null;
            
            // Пробуем извлечь из названия: "Build 20251223 (9e262f9d) - tplink-c5-v4-16M"
            const nameMatch = name.match(/Build \d+ \([\w]+\) - (.+)$/);
            if (nameMatch && nameMatch[1]) {
                return nameMatch[1];
            }
            
            // Пробуем извлечь из описания: "Router model: tplink-c5-v4-16M"
            if (description) {
                const descMatch = description.match(/Router model:\s*(.+)/);
                if (descMatch && descMatch[1]) {
                    return descMatch[1].trim();
                }
            }
            
            return null;
        }
        
        // Форматирование размера файла (байты в читаемый формат)
        function formatFileSize(bytes) {
            if (typeof bytes !== 'number' || bytes === 0) {
                return '0 B';
            }
            
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            
            // Округляем до 2 знаков после запятой для MB и GB
            const formattedSize = parseFloat((bytes / Math.pow(k, i)).toFixed(i > 1 ? 2 : 0));
            return `${formattedSize} ${sizes[i]}`;
        }
        
        // Обновление интерфейса
        function updateUI() {
            updateToolchainDisplay();
            updateFirmwareDisplay();
            updateModelFilter();
            updateStats();
            applyFilters();
        }
        
        // Обновление отображения toolchain
        function updateToolchainDisplay() {
            const container = document.getElementById('toolchain-files');
            const loading = document.getElementById('toolchain-loading');
            const empty = document.getElementById('toolchain-empty');
            
            loading.style.display = 'none';
            
            if (toolchainReleases.length === 0) {
                empty.style.display = 'block';
                container.innerHTML = '';
                return;
            }
            
            empty.style.display = 'none';
            container.innerHTML = '';
            
            toolchainReleases.forEach(item => {
                const card = createFileCard(item);
                container.appendChild(card);
            });
        }
        
        // Обновление отображения прошивок
        function updateFirmwareDisplay() {
            const container = document.getElementById('firmware-files');
            const loading = document.getElementById('firmware-loading');
            const empty = document.getElementById('firmware-empty');
            
            loading.style.display = 'none';
            
            if (firmwareReleases.length === 0) {
                empty.style.display = 'block';
                container.innerHTML = '';
                return;
            }
            
            empty.style.display = 'none';
            container.innerHTML = '';
            
            firmwareReleases.forEach(item => {
                const card = createFileCard(item);
                container.appendChild(card);
            });
        }
        
        // Создание карточки файла
        function createFileCard(item) {
            const card = document.createElement('div');
            card.className = 'file-card';
            card.dataset.type = item.type;
            card.dataset.model = item.model || '';
            card.dataset.filename = item.fileName.toLowerCase();
            card.dataset.name = item.name.toLowerCase();
            
            const isToolchain = item.type === 'toolchain';
            const dateStr = item.date.toLocaleDateString('ru-RU');
            
            // Парсим дополнительные детали из описания
            let commitHash = '';
            let lastCommitMessage = '';
            let buildDate = '';
            let routerModel = '';
            
            if (item.description) {
                const lines = item.description.split('\n');
                lines.forEach(line => {
                    if (line.includes('Source commit:')) {
                        const match = line.match(/Source commit:\s*([a-f0-9]+)/);
                        if (match && match[1]) {
                            commitHash = match[1].substring(0, 8);
                        }
                    } else if (line.includes('Last commit message:')) {
                        const match = line.match(/Last commit message:\s*(.+)/);
                        if (match && match[1]) {
                            lastCommitMessage = match[1].trim();
                        }
                    } else if (line.includes('Build date:')) {
                        const match = line.match(/Build date:\s*(.+)/);
                        if (match && match[1]) {
                            buildDate = match[1].trim();
                        }
                    } else if (line.includes('Router model:')) {
                        const match = line.match(/Router model:\s*(.+)/);
                        if (match && match[1]) {
                            routerModel = match[1].trim();
                        }
                    }
                });
            }
            
            // Формируем HTML для деталей
            let detailsHtml = `
                <div class="detail-row">
                    <span class="detail-label">Файл:</span>
                    <span class="detail-value">${escapeHtml(item.fileName)}</span>
                </div>
                <div class="detail-row">
                    <span class="detail-label">Размер:</span>
                    <span class="detail-value">${item.size}</span>
                </div>
            `;
            
            if (commitHash) {
                detailsHtml += `
                    <div class="detail-row">
                        <span class="detail-label">Коммит:</span>
                        <span class="detail-value">
                            <span class="commit-hash">${commitHash}</span>
                        </span>
                    </div>
                `;
            }
            
            if (lastCommitMessage) {
                detailsHtml += `
                    <div class="detail-row">
                        <span class="detail-label">Последний коммит:</span>
                        <span class="detail-value commit-message" title="${escapeHtml(lastCommitMessage)}">
                            ${escapeHtml(lastCommitMessage.length > 60 ? lastCommitMessage.substring(0, 60) + '...' : lastCommitMessage)}
                        </span>
                    </div>
                `;
            }
            
            if (buildDate && !isToolchain) {
                detailsHtml += `
                    <div class="detail-row">
                        <span class="detail-label">Дата сборки:</span>
                        <span class="detail-value">${escapeHtml(buildDate)}</span>
                    </div>
                `;
            }
            
            if (routerModel && !item.model && !isToolchain) {
                detailsHtml += `
                    <div class="detail-row">
                        <span class="detail-label">Модель:</span>
                        <span class="detail-value">${escapeHtml(routerModel)}</span>
                    </div>
                `;
            }
            
            card.innerHTML = `
                <div class="card-header">
                    <span class="card-type ${isToolchain ? 'type-toolchain' : 'type-firmware'}">
                        ${isToolchain ? 'TOOLCHAIN' : 'ПРОШИВКА'}
                    </span>
                    <span class="card-date">${dateStr}</span>
                </div>
                <div class="card-title">${escapeHtml(item.name)}</div>
                ${item.model ? `<div class="card-model">${escapeHtml(item.model)}</div>` : ''}
                <div class="card-details">
                    ${detailsHtml}
                </div>
                <a href="${item.downloadUrl}" class="download-btn" download="${item.fileName}">
                    Скачать
                </a>
            `;
            
            return card;
        }
        
        // Обновление фильтра моделей
        function updateModelFilter() {
            modelFilter.innerHTML = '<option value="all">Все модели</option>';
            
            const sortedModels = Array.from(routerModels).sort();
            sortedModels.forEach(model => {
                const option = document.createElement('option');
                option.value = model;
                option.textContent = model;
                modelFilter.appendChild(option);
            });
        }
        
        // Обновление статистики
        function updateStats() {
            document.getElementById('toolchain-count').textContent = toolchainReleases.length;
            document.getElementById('firmware-count').textContent = firmwareReleases.length;
            document.getElementById('models-count').textContent = routerModels.size;
        }
        
        // Применение фильтров
        function applyFilters() {
            const searchTerm = searchInput.value.toLowerCase().trim();
            const selectedType = typeFilter.value;
            const selectedModel = modelFilter.value;
            
            const toolchainCards = document.querySelectorAll('#toolchain-files .file-card');
            const firmwareCards = document.querySelectorAll('#firmware-files .file-card');
            
            let visibleToolchain = 0;
            let visibleFirmware = 0;
            
            // Фильтрация toolchain
            toolchainCards.forEach(card => {
                const matchesType = selectedType === 'all' || selectedType === 'toolchain';
                const matchesSearch = !searchTerm || 
                    card.dataset.filename.includes(searchTerm) || 
                    card.dataset.name.includes(searchTerm);
                
                const isVisible = matchesType && matchesSearch;
                card.style.display = isVisible ? 'block' : 'none';
                
                if (isVisible) visibleToolchain++;
            });
            
            // Фильтрация прошивок
            firmwareCards.forEach(card => {
                const matchesType = selectedType === 'all' || selectedType === 'firmware';
                const matchesModel = selectedModel === 'all' || card.dataset.model === selectedModel;
                const matchesSearch = !searchTerm || 
                    card.dataset.filename.includes(searchTerm) || 
                    card.dataset.name.includes(searchTerm) ||
                    (card.dataset.model && card.dataset.model.includes(searchTerm));
                
                const isVisible = matchesType && matchesModel && matchesSearch;
                card.style.display = isVisible ? 'block' : 'none';
                
                if (isVisible) visibleFirmware++;
            });
            
            // Показ/скрытие сообщений "нет данных"
            document.getElementById('toolchain-empty').style.display = 
                visibleToolchain === 0 && toolchainReleases.length > 0 ? 'block' : 'none';
            
            document.getElementById('firmware-empty').style.display = 
                visibleFirmware === 0 && firmwareReleases.length > 0 ? 'block' : 'none';
        }
        
        // Показать/скрыть индикатор загрузки
        function showLoading(show) {
            const toolchainLoading = document.getElementById('toolchain-loading');
            const firmwareLoading = document.getElementById('firmware-loading');
            
            if (show) {
                toolchainLoading.style.display = 'block';
                firmwareLoading.style.display = 'block';
                document.getElementById('toolchain-files').innerHTML = '';
                document.getElementById('firmware-files').innerHTML = '';
                document.getElementById('toolchain-empty').style.display = 'none';
                document.getElementById('firmware-empty').style.display = 'none';
            } else {
                toolchainLoading.style.display = 'none';
                firmwareLoading.style.display = 'none';
            }
        }
        
        // Показать ошибку
        function showError(message) {
            errorMessage.textContent = message;
            errorMessage.classList.add('show');
        }
        
        // Скрыть ошибку
        function hideError() {
            errorMessage.classList.remove('show');
        }
        
        // Показать информационное сообщение
        function showInfo(message) {
            infoMessage.textContent = message;
            infoMessage.classList.add('show');
        }
        
        // Скрыть информационное сообщение
        function hideInfo() {
            infoMessage.classList.remove('show');
        }
        
        // Экранирование HTML
        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Настройка обработчиков событий
        function setupEventListeners() {
            searchInput.addEventListener('input', applyFilters);
            typeFilter.addEventListener('change', applyFilters);
            modelFilter.addEventListener('change', applyFilters);
            
            refreshBtn.addEventListener('click', () => {
                loadReleases(true);
            });
            
            forceRefreshBtn.addEventListener('click', () => {
                // Очищаем кэш и загружаем данные
                localStorage.removeItem(STORAGE_KEY);
                localStorage.removeItem(DATA_STORAGE_KEY);
                loadReleases(true);
            });
        }
    </script>
</body>
</html>
